\section{其他}
\input{Syntax/Complexity/main.tex}
指標是紀錄記憶體的位址的變數，不管是基礎型態或自定義型態皆可用指標，指標的可以讓你直接對記憶體操作。而指標對學習者是一到難度高的門檻，但在程式競賽中，是不可或缺的。\\ 指標在程競中會用到的地方是"動態記憶體配置"，這在比較進階的資料型態會比較常出現。
\lstinputlisting{Syntax/pointer.cpp}
\lstinputlisting{Syntax/pointer2.cpp}
\subsection{algorithm}
\subsubsection{sort}
這個函式傳入兩個變數，代表容器(array 或是 vector)的頭尾$[a,b)$，這裡的b不會排序，用來指示為結尾，例如要排序a陣列的第0到第5個元素。
\lstinputlisting{Syntax/sort.cpp}
此函數的複雜度圍$O(n\log n)$，n為排序的個數
\subsubsection{min/max}
min和max原本在c定義在math.h內，c++將它移入algorithm中
\lstinputlisting{Syntax/minmax.cpp}
\subsubsection{lower\_bound/upper\_bound}
這兩個函式會在"有序序列"中尋找值，前兩個值放的是容器(array 或是 vector)的頭尾[a,b)，第三的是比較的值val。
\lstinputlisting{Syntax/bound1.cpp}
如果要將位置傳換成數字，直接減起始位置就可，下面是一個範例(from cplusplus)：
\lstinputlisting{Syntax/bound2.cpp}
\subsubsection{next\_permutation/prev\_permutation}
這兩個函式會幫你的陣列轉為後/前一個字典序，如果沒有後/前一個字典序，這個函式會回傳false，也不會有任何改變，以下為範例(from cplusplus)：
\lstinputlisting{Syntax/permutation.cpp}
\subsection{cmath}
\subsubsection{atan/atan2} 
atan/atan2函數是將斜率轉為弧度，如果要在轉為角度就以180度除以PI就好，而atan直接傳入斜率，atan2則是座標，atan2可以處理x=0的狀況，比atan好用。
\lstinputlisting{Syntax/atan.cpp}
\subsubsection{log/log2/log10}
這些都是常用對數函數分別以e,2,10為底
\lstinputlisting{Syntax/log.cpp}
\subsubsection{pow}
此函數會回傳以base為底的exponent次方，若$\geq 10^6$，就會輸出科學記號。
\lstinputlisting{Syntax/pow.cpp}
\subsubsection{sqrt}
此函數會回傳x的根號次方
\lstinputlisting{Syntax/sqrt.cpp}
\subsection{iomanip}
\subsubsection{setw}
這個函式會將傳入的整數設定輸出寬度後輸出。
\lstinputlisting{Syntax/setw.cpp}
\subsubsection{setprecision}
這個函式設定輸出到小數點後幾位。
\lstinputlisting{Syntax/setprecision.cpp}
\subsection{extra syntax}
\subsubsection{break, continue, return}
\begin{enumerate}
\item break：跳出迴圈
\item continue：這輪不做，到下一輪
\item return：跳出函式，並回傳值
\end{enumerate}
在break, continue, return後的else是無用的，因為如果這三種指令執行了，後面的東西就根本不會執行到。
\subsubsection{const}
const用途在於宣告這個變數式不能更動的，這適合用來宣告常數。
\lstinputlisting{Syntax/const.cpp}
\subsubsection{static}
如果一個變數被宣告為static，那麼他只會被宣告一次，直到整個程式結束才被刪除。
\lstinputlisting{Syntax/static2.cpp}
\subsubsection{define}
不知道各位有沒有用過excel中的巨集，他可以幫你做重複性高的動作，C++中的define可以幫你做類似的事。
\lstinputlisting{Syntax/define.cpp}
由上面範例可見，define 可以取代程式中出現的特定字元，還可以帶參數，為了要讓使用define後的結果是正確的，請將取代後的字元括號起來，否則會輸出非預期的結果如上面範例第9行
\lstinputlisting{Syntax/define.cpp}
\subsubsection{typedef}
typedef 可以為型態取別名，在之後用到要宣告該型態的時候，可以打該型態之別名，減省時間。C++11開始可以用using來達到相同的事。
\lstinputlisting{Syntax/typedef.cpp}
\subsubsection{auto}
C++11開始，新增了一個關鍵字叫auto，auto可以自動判別變數型態，但必須給他初始值，否則他無法判別型態，C++14開始，可用在function回傳值
\lstinputlisting{Syntax/auto.cpp}
\subsubsection{range\_based for}
C++11開始有另外一種for是range\_based，他只要給兩個參數，一個變數指定資料型態並提供遍歷，另一個為要遍歷的範圍，例子如下。
\lstinputlisting{Syntax/rangebasefor.cpp}
\subsection{lambda}
方便地定義匿名函式
\subsubsection{lambda-introducer}
也叫Capture clause，宣告外部變數(在可視範圍(scope)內)傳入此函式內的方法。
\begin{enumerate}
\item `[]`:只有兩個中括號，完全不抓取外部的變數。
\item `[=]`：所有的變數都以傳值(call by value)的方式抓取
\item `[\&]`：所有的變數都以傳參考(call by reference)的方式抓取
\item `[x,\&y]`：x變數使用傳值，y變數使用傳參考
\item `[=,\&y]`：除了y變數使用傳參考以外。其餘的變數皆使用傳值的方式
\item `[\&,x]`：除了x變數使用傳值以外，其餘的變數皆使用傳參考的方式
\end{enumerate}
\subsubsection{lambda declarator}
也叫參數清單，傳入此函式對應資料。
\subsubsection{mutable specification}
指定以傳值方式抓取進來的外部變數，如果用不到可省略。
與一般函數的傳入參數之異
\begin{enumerate}
\item 不可指定參數的預設值。
\item 不可使用可變長度的參數列表。
\item 參數列表不可以包含沒有命名的參數。
\end{enumerate}
\subsubsection{例外狀況規格}
指定該函示會丟出的例外，其使用的方法跟一般函數的例外指定方式一樣，如果用不到可省略。
\subsubsection{傳回值型別}
指定lambda expression傳回型別，如果 lambda expression 所定義的函數很單純，只有包含一個傳回陳述式（statement）或是根本沒有傳回值的話，可省略(optional)
\subsubsection{compound-statement}
亦稱為 Lambda 主體(lambda body)，跟一般的函數內容一樣。\\ \\
最後來看個lambda範例，結束這一章節。
\lstinputlisting{Syntax/lambda1.cpp}
\lstinputlisting{Syntax/lambda2.cpp}